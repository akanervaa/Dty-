from pyomo.environ import *
import matplotlib.pyplot as plt
import numpy as np
import myData
import json

def optimize_power_system(myData, PowerCosts, i=-1, duration=0, n_new=[0]):
    model = ConcreteModel()
    model.PowerCosts = Param(myData.Time, initialize=PowerCosts)
    model.costindex = Param(within=Integers, initialize=i)
    # ------------- Variables
    model.Storages = Var(myData.Time, myData.Storages, bounds=(myData.V_min_ox, myData.V_max_ox))
    model.Powers = Var(myData.Time, myData.Powers, bounds=(myData.P_min, myData.P_max))
    model.realPowers = Var(myData.Time, myData.realPowers, bounds=(myData.P_min, myData.P_max))
    model.wastePowers = Var(myData.Time, myData.wastePowers, bounds=(0, myData.P_max))
    model.Sewage_storages = Var(myData.Time, myData.Sewage_Storage, within=NonNegativeReals)
    model.Diluted_Oxygen = Var(myData.Time, myData.Diluted_Oxygen, bounds=(
        myData.O_transfer_min, myData.O_transfer_max))
   
    # There should be same amount of oxygen generated by the aerators as there is lost in the
    # inefficiencies and consumed by biological processes

    def Energy_balance_rule(model, i, j, k, z):
        if myData.Diluted_Oxygen.index(z) == myData.Storages.index(j) == myData.Powers.index(k):
            if i == 0:
                return model.Storages[i, j] == (1-(myData.septic_sewage[len(myData.Time)-1]+myData.municipal_ww[len(myData.Time)-1])/myData.Tank_volume/myData.efficiency)*model.Storages[len(myData.Time)-1, j] \
                    + ((myData.septic_sewage[len(myData.Time)-1]+myData.municipal_ww[len(myData.Time)-1])/myData.Tank_volume)*model.Storages[len(myData.Time)-1, myData.Storages[myData.Storages.index(j)-1]] + model.Powers[len(myData.Time)-1, k]/myData.powerfactor \
                    - model.Diluted_Oxygen[len(myData.Time)-1, z] 
            else:
                return model.Storages[i, j] == (1-(myData.septic_sewage[i-1]+myData.municipal_ww[i-1])/myData.Tank_volume/myData.efficiency)*model.Storages[i-1, j] \
                    + ((myData.septic_sewage[i-1]+myData.municipal_ww[i-1])/myData.Tank_volume)*model.Storages[i-1, myData.Storages[myData.Storages.index(j)-1]] + model.Powers[i-1, k]/myData.powerfactor \
                    - model.Diluted_Oxygen[i-1, z] 
        else:
            return Constraint.Skip
    model.Energy_balance = Constraint(myData.Time, myData.Storages, myData.Powers, myData.Diluted_Oxygen, rule=Energy_balance_rule)
    
    
    def power_waste_rule(model, a,i,j,k):
        if myData.Powers.index(j) == myData.realPowers.index(i) == myData.wastePowers.index(k):
            return model.realPowers[a,i] == model.Powers[a,j] - model.wastePowers[a,k]
        else:
            return Constraint.Skip
    model.power_waste = Constraint(myData.Time,myData.realPowers,myData.Powers,myData.wastePowers, rule=power_waste_rule)
    # THESE TWO CONSTRAINTS ARE ADJUSTABLE TO SEE THE EFFECTS ON FLEXIBILITY.
    # There should be little sewage at the last storage, it almost all of it should be dissolved with oxygen
    def Sewage_demand_rule(model, i):
            return model.Sewage_storages[i, 'Sewage 5'] <= 20
    model.Sewage_demand = Constraint(myData.Time, rule=Sewage_demand_rule)

    # The sum of excess sewage over time should be less than a specific amount set by regulations, more important factor than sewage at the last storage
    # The last storage sewage demand rule should be more loose since it is the average excess sewage over time that matters in terms of water quality.

    def Sewage_demand_rule2(model, i):
        return sum((myData.municipal_ww[i]*myData.municipal_BOD+myData.septic_sewage[i]*myData.septic_BOD)/myData.Tank_volume for i in myData.Time) - sum(model.Diluted_Oxygen[i, Unit]*myData.alfa for Unit in myData.Diluted_Oxygen for i in myData.Time) <= 80
    model.Sewage_demand2 = Constraint(rule=Sewage_demand_rule2)

    # upward- and downward regulation for power flex
    def Power_rule(model, i):
        if myData.locked_power_flex[i]['up/down'] == 'down':
                return sum(model.Powers[i, j] for j in myData.Powers) <= myData.locked_power_flex[i]['Amount']
        elif myData.locked_power_flex[i]['up/down'] == 'up':
                return sum(model.Powers[i, j] for j in myData.Powers) >= myData.locked_power_flex[i]['Amount']
        else:
            return Constraint.Skip
    model.Power_constraint = Constraint(myData.Time, rule=Power_rule)

    # upward- and downward regulation for energy flex
    def Energy_rule(model, i):
        if myData.locked_energy_flex[i]['up/down'] == 'down':
                return sum(model.Powers[i+d, j] for j in myData.Powers for d in range(myData.locked_energy_flex[i]['Duration'])) <= myData.locked_energy_flex[i]['Amount']
        elif myData.locked_energy_flex[i]['up/down'] == 'up':
                return sum(model.Powers[i+d, j] for j in myData.Powers for d in range(myData.locked_energy_flex[i]['Duration'])) >= myData.locked_energy_flex[i]['Amount']
        else:
            return Constraint.Skip
    model.Energy_constraint = Constraint(myData.Time, rule=Energy_rule)
    # upward- and downward regulation for energy flex

    def Power_calc_rule(model, k):
        if model.costindex != -1 and k < len(myData.Time)-1:
            if(myData.locked_power_flex[k]['up/down'] == myData.locked_power_flex[k+1]['up/down'] != "N/A"):
                return sum(model.Powers[k, j] for j in myData.Powers) - n_new[k] == sum(model.Powers[k+1, j] for j in myData.Powers) - n_new[k+1]
            else:
                return Constraint.Skip
            # print(model.costindex.value)
        else:
            return Constraint.Skip
    model.Power_calc_constraint = Constraint(myData.Time, rule=Power_calc_rule)

    # Same propotional amount of waste should be dissolved as there is entering oxygen
    def Sewage_balance_rule(model, i, j, z):
        if myData.Sewage_Storage.index(j) == myData.Diluted_Oxygen.index(z):
            if i == 0:
                if j == 'Sewage 1':
                    return model.Sewage_storages[i, j] == (1-(myData.septic_sewage[len(myData.Time)-1]+myData.municipal_ww[len(myData.Time)-1])/myData.Tank_volume)*model.Sewage_storages[len(myData.Time)-1, j] \
                        + myData.septic_sewage[len(myData.Time)-1]*myData.septic_BOD/myData.Tank_volume+myData.municipal_ww[len(myData.Time)-1]*myData.municipal_BOD/myData.Tank_volume\
                            -myData.alfa*model.Diluted_Oxygen[len(myData.Time)-1, z]
                else:
                    return model.Sewage_storages[i, j] == (1-(myData.septic_sewage[len(myData.Time)-1]+myData.municipal_ww[len(myData.Time)-1])/myData.Tank_volume)*model.Sewage_storages[len(myData.Time)-1, j] \
                        +((myData.septic_sewage[len(myData.Time)-1]+myData.municipal_ww[len(myData.Time)-1])/myData.Tank_volume)*model.Sewage_storages[len(myData.Time)-1, myData.Sewage_Storage[myData.Sewage_Storage.index(j)-1]] \
                            - myData.alfa*model.Diluted_Oxygen[len(myData.Time)-1, z]
            if j == 'Sewage 1':
                return model.Sewage_storages[i, j] == (1-(myData.septic_sewage[i-1]+myData.municipal_ww[i-1])/myData.Tank_volume)*model.Sewage_storages[i-1, j] \
                     + myData.septic_sewage[i-1]*myData.septic_BOD/myData.Tank_volume+myData.municipal_ww[i-1]*myData.municipal_BOD/myData.Tank_volume \
                        - myData.alfa*model.Diluted_Oxygen[i-1, z]
            else:
                return model.Sewage_storages[i, j] == (1-(myData.septic_sewage[i-1]+myData.municipal_ww[i-1])/myData.Tank_volume)*model.Sewage_storages[i-1, j] \
                    +((myData.septic_sewage[i-1]+myData.municipal_ww[i-1])/myData.Tank_volume)*model.Sewage_storages[i-1, myData.Sewage_Storage[myData.Sewage_Storage.index(j)-1]] \
                        - myData.alfa*model.Diluted_Oxygen[i-1, z]
        else:
            return Constraint.Skip
    model.Sewage_balance = Constraint(myData.Time, myData.Sewage_Storage, myData.Diluted_Oxygen, rule=Sewage_balance_rule)



    # ------------- Objective function
    # minimize the aerator usage.
    def objective_func(model):
        # sum the price times power produced for all time steps
        # return sum(1 *(model.Powers[t,Unit]) for t in myData.Time for Unit in myData.Powers)
        return sum(model.PowerCosts[t] * (model.Powers[t, Unit]) for t in myData.Time for Unit in myData.Powers)


    model.objective = Objective(rule = objective_func)

    # set up the solver
    solver = SolverFactory('glpk')
    # run the simulation, for debugging you can set keepfiles as true and it will
    # create solve.log for you
    results = solver.solve(model, keepfiles=False, logfile="solve.log")
    # Extract values from the Pyomo model
    #model.Diluted_Oxygen.pprint()
    #model.Sewage_storages.pprint()
    V1_values= []
    V2_values= []
    V3_values= []
    V4_values= []
    V5_values= []
    P1_values= []
    P2_values= []
    P3_values= []
    P4_values= []
    P5_values= []
    SV1_values= []
    SV2_values= []
    SV3_values= []
    SV4_values= []
    SV5_values= []
    DO1_Values = []
    for i in myData.Time:
        V1_values.append(model.Storages[i, 'Storage 1']())
        V2_values.append(model.Storages[i, 'Storage 2']())
        V3_values.append(model.Storages[i, 'Storage 3']())
        V4_values.append(model.Storages[i, 'Storage 4']())
        V5_values.append(model.Storages[i, 'Storage 5']())
        SV1_values.append([model.Sewage_storages[i, 'Sewage 1']()])
        SV2_values.append([model.Sewage_storages[i, 'Sewage 2']()])
        SV3_values.append([model.Sewage_storages[i, 'Sewage 3']()])
        SV4_values.append([model.Sewage_storages[i, 'Sewage 4']()])
        SV5_values.append([model.Sewage_storages[i, 'Sewage 5']()])
        P1_values.append(model.Powers[i, 'Power 1']()/myData.powerfactor)
        P2_values.append(model.Powers[i, 'Power 2']()/myData.powerfactor)
        P3_values.append(model.Powers[i, 'Power 3']()/myData.powerfactor)
        P4_values.append(model.Powers[i, 'Power 4']()/myData.powerfactor)
        P5_values.append(model.Powers[i, 'Power 5']()/myData.powerfactor)
        DO1_Values.append(model.Diluted_Oxygen[i,'Oxygen 1']())
    V1_values_temp = np.insert(V1_values, 0, 0)
    dV1_values = -np.diff(V1_values_temp)
    V2_values_temp = np.insert(V2_values, 0, 0)
    dV2_values = -np.diff(V2_values_temp)
    V3_values_temp = np.insert(V3_values, 0, 0)
    dV3_values = -np.diff(V3_values_temp)
    V4_values_temp = np.insert(V4_values, 0, 0)
    dV4_values = -np.diff(V4_values_temp)
    V5_values_temp = np.insert(V5_values, 0, 0)
    dV5_values = -np.diff(V5_values_temp)
    return P1_values, P2_values, P3_values, P4_values, P5_values, V1_values, V2_values, V3_values, V4_values, V5_values, dV1_values, dV2_values, dV3_values, dV4_values, dV5_values, SV1_values, SV2_values, SV3_values, SV4_values, SV5_values, DO1_Values, results, model

